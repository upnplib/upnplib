#ifndef UPNPLIB_SOCKET_HPP
#define UPNPLIB_SOCKET_HPP
// Copyright (C) 2023+ GPL 3 and higher by Ingo Höft, <Ingo@Hoeft-online.de>
// Redistribution only with this Copyright remark. Last modified: 2024-05-10
/*!
 * \file
 * \brief **Socket Module:** manage properties and methods but not connections
 * of ONE network socket to handle IPv4 and IPv6 streams and datagrams.
 */

/*!
 * \addtogroup upnplibAPI-socket
* Helpful link for ip address structures:
<!--REF:-->[sockaddr&#20;structures&#20;as&#20;union](https://stackoverflow.com/a/76548581/5014688).

* This module mainly consists of the CSocket class but also provides free
* functions to manage a socket. The problem is that socket handling isn't very
* good portable. There is different behavior on the supported platforms Unix,
* MacOS and Microsoft Windows. The CSocket class atempts to be consistent
* portable on all three platforms by using common behavior or by emulating
* missing functions on a platform.
*
* Specification for CSocket
* =========================
* The class encapsulates and manages one raw socket file descriptor. The file
* descriptor of a valid socket object cannot be changed but the object with
* its immutable file descriptor can be moved and assigned to another socket
* object. Copying a socket object isn't supported because having two objects
* with the same file descriptor may be very error prone in particular with
* multithreading. Effort has been taken to do not cache any socket information
* outside the socket file descriptor. All socket informations are direct set
* and get to/from the operating system with the file descriptor. The socket
* file descriptor is always valid except on an empty socket object.
*
* \anchor empty_socket
* empty socket object
* -------------------
* An empty socket object can be instantiated with the default constructor,
* e.g. `CSocket sockObj;`. It is a valid object and should be destructed. When
* moving a socket object, the left over source object is also empty. An empty
* socket object has an `INVALID_SOCKET` defined and no valid content. It
* throws an exception if using any of its Setter and Getter. Moving and
* assigning it is possible.
*
* address family
* --------------
* Only address family `AF_INET6` and `AF_INET` is supported. Any other address
* family throws an exception.
*
* socket type
* -----------
* Only `SOCK_STREAM` and `SOCK_DGRAM` is supported. Any other type throws an
* exception.
*
* valid socket file descriptor
* ----------------------------
* I get this from the C standard library function:
* `int ::%socket(address_family, socket_type, protocol)`.
* Other arguments than address family and socket type do not instantiate a
* valid socket object and throw an exception. For the protocol argument is
* always the default one used that is internal hard coded with argument 0.
*
* options SO_REUSEADDR and SO_EXCLUSIVEADDRUSE
* --------------------------------------------
* I don't set the option to immediately reuse an address and I always set the
* option `SO_EXCLUSIVEADDRUSE` on Microsoft Windows. For more details of this
* have a look at [Socket option "reuse address"](\ref overview_reuseaddr).
*/

#include <upnplib/sockaddr.hpp>
/// \cond
#include <mutex>
#include <memory>

// To be portable with BSD socket error number constants I have to
// define and use these macros with appended 'P' for portable.
#ifdef _MSC_VER
#define EBADFP WSAENOTSOCK
#define ENOTCONNP WSAENOTCONN
#define EINTRP WSAEINTR
#define EFAULTP WSAEFAULT
#define ENOMEMP WSA_NOT_ENOUGH_MEMORY
#else
#define EBADFP EBADF
#define ENOTCONNP ENOTCONN
#define EINTRP EINTR
#define EFAULTP EFAULT
#define ENOMEMP ENOMEM
#endif
/// \endcond

namespace upnplib {

/*!
 * \brief Get information from a raw network socket file descriptor
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 *
 * This class takes the resources and results as given by the platform (Unix,
 * MacOS, MS Windows). It does not perform any emulations for unification. The
 * behavior can be different on different platforms.
 *
 * An object of this class does not take ownership of the raw socket file
 * descriptor and will never close it. This is also the reason why you cannot
 * modify the socket and only have getter available (except the setter for the
 * raw socket file descriptor itself). But it is helpful to easily get
 * information about an existing raw socket file descriptor. Closing the file
 * descriptor is in the responsibility of the caller who created the socket. If
 * you need to manage a socket you must use CSocket.
 */
class UPNPLIB_API CSocket_basic : private SSockaddr {
  public:
    /*! \brief Default constructor for an \ref empty_socket
     * "empty socket object". */
    CSocket_basic();

    // Copy constructor
    // not generated by default with custom move constructor. I want to
    // restrict to only move the resource. Don't enable this.
    // CSocket(const CSocket&);

    // Destructor
    virtual ~CSocket_basic();

    /*! \brief Get raw socket file descriptor.
     * \code
     * // Usage e.g.:
     * CSocket_basic sockObj();
     * try {
     *     sockObj.set(valid_socket_fd);
     * } catch(xcp) { // handle error };
     * SOCKET sfd = sockObj;
     * \endcode */
    operator const SOCKET&() const;


    /*! \name Setter
     * *************
     * @{ */
    /*! \brief Set a given raw socket file descriptor to the object
     *
     * It throws an exception if the raw socket argument is invalid. It does
     * not take ownership of the socket file descriptor and will never close
     * it. Closing is in the responsibility of the caller who created the
     * socket.
     *
     * Throws exception std::runtime_error with an error getting a file
     * descriptor. */
    void set(SOCKET);
    /// @} Setter


    /*! \name Getter
     * *************
     * @{ */
    /*! \brief Get socket [address family](\ref glossary_af)
     *
     * Throws no exception. */
    sa_family_t get_family() const;

    /*! \brief Get [netaddress](\ref glossary_netaddr) without port.
     *
     * Throws no exception. */
    const netaddr_t& get_netaddr() override;

    /*! \brief Get [netaddress](\ref glossary_netaddr) with port.
     *
     * Throws no exception. */
    const netaddr_t& get_netaddrp() override;

    /*! \brief Get the [port](\ref glossary_port) number.
     *
     * Throws no exception. */
    in_port_t get_port() const override;

    /*! \brief Get the [socket type](\ref glossary_socktype) `SOCK_STREAM` or
     * `SOCK_DGRAM`.
     *
     * Throws exception std::runtime_error if query option fails.
     *
     * \todo Check if SOCK_UNDEF is also possible, maybe with an empty socket */
    int get_socktype() const;

    /*! \brief Get the error that is given from the socket as option.
     *
     * This is not a system error from the operating system (with POSIX
     * returned in errno). It is the more specific error that can be queried as
     * option from the socket.
     *
     * Throws exception std::runtime_error if query option fails. */
    int get_sockerr() const;

    /*! \brief Get status if reusing address is enabled.
     *
     * For details to this option have a look at
     * [option "reuse address"](\ref overview_reuseaddr).
     *
     * Throws exception std::runtime_error if query option fails. */
    bool is_reuse_addr() const;

    /*! \brief Get status if socket is bound to a local
     * \glos{netaddr,netaddress}.
     *
     * I assume that a valid socket file descriptor with unknown address (all
     * zero) and port 0 is not bound. */
    bool is_bound();
    /// @} Getter

  protected:
    /// \cond
    // This is the raw socket file descriptor
    SOCKET m_sfd{INVALID_SOCKET};

    // Mutex to protect concurrent binding a socket.
    SUPPRESS_MSVC_WARN_4251_NEXT_LINE
    mutable std::mutex m_bound_mutex;
    /// \endcond

  private:
    // Helper method
    void m_get_addr_from_socket(int line) const;
};


/*!
 * \brief Manage all aspects of a network socket.
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 *********************************************** */
class UPNPLIB_API CSocket : public CSocket_basic {
  public:
    /*! \brief Default constructor for an
     * [empty socket object](\ref empty_socket), needs to be set() */
    CSocket();

    /*! \brief Move constructor
     *
     * This moves the socket object to a new instantiated socket object and
     * also transfers ownership to the new object. That means the destination
     * also manage and frees its resources now. After moving, the source object
     * is still valid but empty with an INVALID_SOCKET. Using its methods will
     * throw exceptions. But you can assign (operator=()) another socket object
     * to it again.
     * \code
     * ~$ // Usage e.g.:
     * ~$ CSocket sock1Obj;
     * ~$ try {
     * ~$     sock1Obj.set(AF_INET6, SOCK_STREAM);
     * ~$ } catch(xcp) { // handle error }
     * ~$ CSocket sock2Obj{std::move(sock1Obj)};
     * \endcode
     * */
    CSocket(CSocket&&);

    /*! \brief Assignment operator
     *
     * <!-- With parameter as value this is used as copy- and move-assignment
     * operator. The correct usage (move) is evaluated by the compiler. Here
     * only the move constructor can be used. -->
     * This moves the socket object to another already existing socket object
     * and also transfers ownership to it. That means the destination object
     * also manage and frees its resources now. After moving, the source object
     * is still valid but empty with an INVALID_SOCKET. Using its methods will
     * throw exceptions.
     * \code
     * ~$ // Usage e.g.:
     * ~$ CSocket sock1Obj;
     * ~$ try {
     * ~$     sock1Obj.set(AF_INET6, SOCK_STREAM);
     * ~$ } catch(xcp) { // handle error }
     * ~$ CSocket sock2Obj;
     * ~$ sock2Obj = std::move(sock1Obj);
     * \endcode */
    CSocket& operator=(CSocket);

    /// \brief Destructor
    virtual ~CSocket();

    /*! \name Setter
     * *************
     * @{ */

    /*! \brief Set arguments to get a socket file descriptor
     * \code
     * ~$ // Usage e.g.:
     * ~$ CSocket sockObj;
     * ~$ try {
     * ~$     sockObj.set(AF_INET6, SOCK_STREAM);
     * ~$ } catch(xcp) { // handle error }
     * \endcode */
    void set(
        /*! [in] `AF_INET6` or `AF_INET` */
        sa_family_t a_family,
        /*! [in] `SOCK_STREAM` or `SOCK_DGRAM` */
        int a_socktype);

    /*! \brief Set IPV6_V6ONLY
     * - IPV6_V6ONLY = false means allowing IPv4 and IPv6 on one interface.
     * - This flag can only be set on sockets of address family AF_INET6.
     * - It is always false on a socket with address family AF_INET.
     * - It can never be modified on a sochet that is already bound to a local
     *   address.
     * - If Flag AI_PASSIVE **is** set (passive mode for listening on local
     *   addresses): IPV6_V6ONLY can be modified before binding it to an
     *   address. The setting persists after bind(). This means the socket can
     *   listen to IPv6 and IPv4 connections if IPV6_V6ONLY is set to false.
     * - If Flag AI_PASSIVE **not** set (passive mode isn't set): IPV6_V6ONLY
     *   will always be set to true no matter what it should be set. More
     *   details at note to bind().
     *
     * If one of the conditions above doesn't match, the setter silently
     * ignores the request and will not modify the socket. Other system errors
     * may throw an exception (e.g. using an invalid socket etc.).
     *
     * To get the current setting use CSocket::is_v6only(). */
    void set_v6only(const bool);

    /*! \brief Bind socket to a local interface address
     * \code
     * ~$ // Usage e.g.:
     * ~$ CSocket sockObj;
     * ~$ try {
     * ~$     sockObj.set(AF_INET6, SOCK_STREAM);
     * ~$     sockObj.bind("[::1]", "8080");
     * ~$ } catch(xcp) { // handle error }
     * \endcode
     *
     * If the AI_PASSIVE flag is specified, and **a_node** is empty (""), then
     * the selected local socket addresses will be suitble for **binding** a
     * socket that will **accept** connections. The selected local socket
     * address will contain the "wildcard address" (INADDR_ANY for IPv4
     * addresses, IN6ADDR_ANY_INIT for IPv6 address). The wildcard address is
     * used by applications (typically servers) that intend to accept
     * connections on any of the host's network addresses. If **a_node** is not
     * empty (""), then the AI_PASSIVE flag is ignored.
     * \code
     * // typical for server listening
     * ~$ sockObj.bind("", "54839", AI_PASSIVE);
     * \endcode
     *
     * If the AI_PASSIVE flag is not set, then the selected local socket
     * addresses will be suitable for use with **connect**, **sendto**, or
     * **sendmsg** (typically clients). If **a_node** is empty ("") and flag
     * AI_NUMERICHOST not set then you will get an exception: no address for
     * hostname "". With AI_NUMERICHOST the unknown address "[::]" or "0.0.0.0"
     * is used.
     * \code
     * ~$ // typical for client connect
     * ~$ sockObj.bind("[2001:db8::1]", "49123");
     * ~$ // or
     * ~$ sockObj.bind("", "51593"); // uses "[::1]:51593" or "127.0.0.1:51593"
     * \endcode
     *
     * There is additional information at <a
     * href="https://www.man7.org/linux/man-pages/man3/getaddrinfo.3.html">getaddrinfo(3)
     * — Linux manual page</a>.
     *
     * With address family AF_INET6 and not passive mode (**a_flags** not set
     * to AI_PASSIVE) I internally always set IPV6_V6ONLY to true no matter
     * what is given with **a_flags**. This is the behavior on Unix platforms
     * when binding the address and cannot be modified. MacOS does not modify
     * IPV6_V6ONLY with binding. On Microsoft Windows IPV6_V6ONLY is already
     * set by default. To be portable with same behavior on all platforms I
     * always set IPV6_V6ONLY before binding and cannot be modified afterwards.
     *
     * There is additional information at set_v6only() */
    void bind(
        /*! [in] local interface address */
        const std::string& a_node,
        /*! [in] Port of the local interface address. This is a string argument
         * to be able to use service names instead of only numbers. */
        const std::string& a_port,
        /*! [in] Optional: this field specifies additional options, as
         * described at <a
         * href="https://www.man7.org/linux/man-pages/man3/getaddrinfo.3.html">getaddrinfo(3)
         * — Linux manual page</a>. Multiple flags are specified by bitwise
         * OR-ing them together. Example is: `AI_PASSIVE | AI_NUMERICHOST |
         * AI_NUMERICSERV` */
        const int a_flags = 0);

    /*! \brief Set socket to listen
     *
     * On Linux there is a socket option SO_ACCEPTCONN that can be get with
     * system function ::%getsockopt(). This option shows if the socket is set
     * to passive listen. But it is not portable. MacOS does not support it. So
     * this flag has to be managed here. Look for details at <!--REF:--><a
     * href="https://stackoverflow.com/q/75942911/5014688">How to get option on
     * MacOS if a socket is set to listen?</a> */
    void listen();
    /// @} Setter


    /*! \name Getter
     * *************
     * @{ */
    /*! \brief Get status of IPV6_V6ONLY flag
     *
     * IPV6_V6ONLY == false means allowing IPv4 and IPv6. */
    bool is_v6only() const;

    /// \brief Get status if the socket is listen to incomming network packets.
    bool is_listen() const;
    /// @} Getter

  private:
    /// \brief Mutex to protect concurrent listen a socket.
    SUPPRESS_MSVC_WARN_4251_NEXT_LINE
    mutable std::mutex m_listen_mutex;
    bool m_listen{false}; // Protected by a mutex.
};


// Initialize and cleanup Microsoft Windows Sockets
// ================================================
// Winsock needs to be initialized before using it and it needs to be freed. I
// do that with a class, following the RAII paradigm. Multiple initialization
// doesn't matter. This is managed by the operating system with a counter. It
// ensures that winsock is initialzed only one time and freed with the last
// free call. --Ingo

#ifdef _MSC_VER
class UPNPLIB_API CWSAStartup {
  public:
    CWSAStartup();
    virtual ~CWSAStartup();
};

#define WINSOCK_INIT upnplib::CWSAStartup winsock_init;
#else
#define WINSOCK_INIT
#endif // _MSC_VER


/*!
 * \brief Portable catch **one** network socket error from the operating
 * system, and provide information about it.
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 *
 * This is a C++ interface for dependency injection of different
 * \glos{depinj,di-services}, e.g. for production or Unit Tests (mocking).
 */
class UPNPLIB_API ISocketErr {
  public:
    ISocketErr();
    virtual ~ISocketErr();
    /// Get error number.
    virtual operator const int&() = 0;
    /// Catch error for later use.
    virtual void catch_error() = 0;
    /// Get human readable error description of the catched error.
    virtual std::string get_error_str() const = 0;
};

/*!
 * \brief Smart pointer to \glos{depinj,di-service} objects that handle network
 * socket errors and used to inject the objects.
 * \ingroup upnplib-socket
 */
using PSocketErr = std::shared_ptr<ISocketErr>;

/*!
 * \brief \glos{depinj,di-service} for portable handling of network socket
 * errors.
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 *
 * There is a compatibility problem with Winsock2 on the Microsoft Windows
 * platform that does not support detailed error information given in the global
 * variable 'errno' that is used by POSIX. Instead it returns them with calling
 * 'WSAGetLastError()'. This class encapsulates differences so there is no need
 * to always check the platform to get the error information.
 */
class UPNPLIB_API CSocketErrService : public ISocketErr {
  public:
    CSocketErrService();
    virtual ~CSocketErrService() override;
    /// Get error number.
    virtual operator const int&() override;
    /// Catch error for later use.
    virtual void catch_error() override;
    /// Get human readable error description of the catched error.
    virtual std::string get_error_str() const override;

  private:
    int m_errno{}; // Cached error number
};

/*!
 * \brief \glos{depinj,di-client} for portable handling of network socket
 * errors with injected \glos{depinj,di-service}.
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 *
 * Usage of the class:
 * \code
 * CSocketErrService sockerrObj;
 * int ret = some_function_1();
 * if (ret != 0) {
 *     sockerrObj.catch_error();
 *     int errid = sockerrObj;
 *     std::cout << "Error " << errid << ": "
 *               << sockerrObj.get_error_str() << "\n";
 * }
 * ret = some_function_2();
 * if (ret != 0) {
 *     sockerrObj.catch_error();
 *     std::cout << "Error " << static_cast<int>(sockerrObj) << ": "
 *               << sockerrObj.get_error_str() << "\n";
 * }
 * \endcode
 */
class CSocketErr {
    // Due to warning C4251 "'type' : class 'type1' needs to have dll-interface
    // to be used by clients of class 'type2'" on Microsoft Windows each member
    // function needs to be decorated with UPNPLIB_API instead of just only the
    // class. The reason is 'm_socket_errObj'.
  public:
    /*! \brief Constructor */
    UPNPLIB_API CSocketErr(
        /*! [in] Inject the used \glos{depinj,di-service} object that is by
         * default the productive one but may also be a mocked object for Unit
         * Tests. */
        PSocketErr a_socket_errObj = std::make_shared<CSocketErrService>());

    /* \brief Destructor */
    UPNPLIB_API virtual ~CSocketErr();

    /*! \brief Get the catched error number.
     * \details The error number is that from the operating system, for example
     * **errno** on Posix platforms or from WSAGetLastError() on Microroft
     * Windows. */
    UPNPLIB_API virtual operator const int&();

    /*! \brief Catches detailed error information.
     *  \details Because error information from the operating system is very
     * volatile this method should be called as early as possible after the
     * error was detected. */
    UPNPLIB_API virtual void catch_error();

    /*! \brief Gets a human readable error description from the operating
     * system that explains the catched error. */
    UPNPLIB_API virtual std::string get_error_str() const;

  private:
    PSocketErr m_socket_errObj;
};

} // namespace upnplib

#endif // UPNPLIB_SOCKET_HPP
