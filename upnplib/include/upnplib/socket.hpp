#ifndef UPNPLIB_SOCKET_CLASS_HPP
#define UPNPLIB_SOCKET_CLASS_HPP
// Copyright (C) 2023+ GPL 3 and higher by Ingo HÃ¶ft, <Ingo@Hoeft-online.de>
// Redistribution only with this Copyright remark. Last modified: 2023-04-15

#include <upnplib/visibility.hpp>
#include <upnplib/port_sock.hpp>
#include <upnplib/addrinfo.hpp>
#include <mutex>

namespace upnplib {

// Initialize and cleanup Microsoft Windows Sockets portable
// ---------------------------------------------------------
#ifdef _MSC_VER
class UPNPLIB_API CWSAStartup {
  public:
    CWSAStartup();
    virtual ~CWSAStartup();
};
// Winsock Init Portable
#define WINSOCK_INIT_P CWSAStartup winsock_init;
#else
#define WINSOCK_INIT_P
#endif


// Wrap socket() system call
// -------------------------
// To copy a socket doesn't make sense. So this class only supports moving a
// socket. After moving, the moved-from object is still valid but contains an
// INVALID_SOCKET. It can be destructed successful.
// An instantiation of this class without arguments or all arguments set to 0
// will give an empty object. You can move another usable CSocket to it.
// REF: [What is move semantics?](https://stackoverflow.com/q/3106110/5014688)

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4251)
// REF: 'type' : class 'type1' needs to have dll-interface to be used by
// clients of class 'type2'
// https://learn.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4251
#endif

class UPNPLIB_API CSocket {
  public:
    // Constructor
    CSocket(int a_domain = 0, int a_type = 0, int a_protocol = 0);

    // Copy constructor
    // not generated by default with custom move member functions. We want to
    // restrict to only move the resource.
    // CSocket(const CSocket&);

    // Move constructor
    CSocket(CSocket&&);

    // Assignment operator
    // With parameter as value this is used as copy- and move-assignment
    // operator. The correct usage (move) is evaluated by the compiler. Here
    // only the move constructor can be used (there is no copy constructor) to
    // move the parameter to the function body.
    CSocket& operator=(CSocket);

    // Destructor
    virtual ~CSocket();

    // Get the socket, e.g.: CSocket sock; SOCKET sfd = sock;
    operator SOCKET&() const;

    // Setter: set socket to bind.
    // Binding a socket address (given with CAddrinfo) with a different socket
    // type (e.g. SOCK_STREAM, SOCK_DGRAM, etc.) than that of the socket is not
    // supported and throw an error.
    void bind(const CAddrinfo& a_addrObj);

    // Setter: set socket to listen.
    // On Linux there is a socket option SO_ACCEPTCONN that can be get with
    // system function ::getsockopt(). This option shows if the socket is set to
    // passive listen. But it is not portable. MacOS does not support it. So
    // this flag has to be managed here. Look for details at
    // REF: [How to get option on MacOS if a socket is set to listen?]
    //      (https://stackoverflow.com/q/75942911/5014688)
    void listen();

    // Getter
    uint16_t get_port() const;
    int get_sockerr() const;
    bool is_reuse_addr() const;
    bool is_v6only() const;
    bool is_bind() const;
    bool is_listen() const;

  private:
    SOCKET m_sfd{INVALID_SOCKET};

    // Cache if system functions where called.
    int m_af{-1}; // used address family e.g. AF_INET6
    mutable std::mutex m_bound_mutex;
    bool m_bound{false}; // Protected by mutex.
    mutable std::mutex m_listen_mutex;
    bool m_listen{false}; // Protected by mutex.

    UPNPLIB_LOCAL int getsockopt_int(int a_level, int a_optname,
                                     const std::string& a_optname_str) const;
};

#ifdef _MSC_VER
#pragma warning(pop)
#endif


// Wrapper function to get an integer socket option
// ------------------------------------------------
bool getsockopt_int(int a_sockfd, int a_level, int a_optname,
                    const std::string& a_optname_str);

} // namespace upnplib

#endif // UPNPLIB_SOCKET_CLASS_HPP
